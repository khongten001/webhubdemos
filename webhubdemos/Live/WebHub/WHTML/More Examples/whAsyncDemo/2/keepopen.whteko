<whteko defaultlingvo="eng" designmode="code">

<whdoc show="no">
 keeping a page open while processing an asynchroneous request.
 (chunks for the 'splitting off' demo)

these are the chunks used by the demonstration code. they are pre-
expanded when the background activity object disconnects the output
stream which connects 'this page' to the waiting surfer and drops into the
background queue (or is driven by its own dedicated thread).

The pascal of the demo application flushes anything that might have have
been sent - while leaving header customizations intact, then delivers
the headers and (~AsyncPageTop~) to the surfer. Take care to send
at least as much data as is required for your target browser to actually
start rendering. that may be a few hundred chars, not sure.

While progressing, the %Complete demo will send (~AsyncPageforEach~)
All demos will send the previously expanded (~AsyncPageDone~)
and (~AsyncPageTail~) chunks surrounding the result-text when done.

 *you MUST not expect Expand or Compareto to work once you've
disconnected from the session object! .. which is what you're doing here
as you are taking control of the output stream. No Access to StringVars at all.

YOU DO of course have access to the background activity object created
by the webaction that drives this demo, as soon as AsyncState is
  asPrior or asFinished.  Access TwhAsyncAction.SurfersObject, and
call .DeleteTask; when you no longer need the results. (Objects expire
after 1hr by default.) Remember! access from the main thread only.


meta refresh will kick in before the page is complete.
does not work to continue a page once the action is done
but might come in handy when used to provide a timeout
<META HTTP-EQUIV="Refresh" CONTENT="1;(~DynURL.ToSessionIDW~)">

<font size=+2>(~ANCHOR|AsyncPage1~)</font><br />
<font size=-1>(~ANCHOR|AsyncPage2~)</font><br />
(~ANCHOR|AsyncPage3~)
</whdoc>

<whdroplet name="AsyncPageTop">
(~mcdoctypehtml~)
<html>
<head>
(~drHead~)
</head>
<body>
(~drPageBegin~)
<div id="whdemopagecontent">
(~AsyncTitle~)
<br/><br/>

(~MATCH|(~AsyncDemo~)!Percent|
(~AsyncPageJS~)
<center>
<font size="+1">
<FORM name="form">
<INPUT TYPE="button" VALUE="..Status.." width="200" NAME="button" onClick="timeInfo()"/>
</FORM>
</font>
</center>

(~Jump|Async,Abort|Abort~)
~)
(~AsyncTitleEnd~)
</whdroplet>

<whdroplet name="AsyncPageForEach">
<whdoc for="AsyncPageForEach" show="no">
This dynamically updates the button on the form created above.
the pascal replaces XXX under thread control
</whdoc>
<script language="JavaScript">
<!-- hide
document.form.button.value = "XXX % Complete";
// -->
</script>
</whdroplet>


//subroutine for AsyncPageTop which contains the javascript used
//in the button's onclick handler tracking elapsed time.
<whdroplet name="AsyncPageJS">
<script>
<!-- vars
day = new Date();
miNow = day.getTime();
miLast = 0;
//
<!-- code
function timeInfo()
{
if (miLast == 0) {day = new Date();
milliNow = day.getTime() - miNow;}
else {milliNow = miLast - miNow;}
alert("You have been waiting " + milliNow / 1000 + " seconds");
} // -->
</script>
</whdroplet>

//at the end of the %Complete demo set a variable to the current time.
//this will let the button.onclick handler event know that the page is done.
<whdroplet name="AsyncPageJSDone">
<script language="JavaScript">
<!--
day = new Date();
miLast = day.getTime();  // -->
</script>
</whdroplet>

<whdoc>
AsyncPageDone and AsyncPageTail are pre-expanded by pascal
and sent before/after the thread's result.
</whdoc>

<!--- begin the 2nd yellow table to display the result-->
<whdroplet name="AsyncPageDone">
(~MATCH|(~AsyncDemo~)!Percent|
(~AsyncPageJSDone~)
<table width="100%" border=3>
<tr><td bgcolor=yellow valign=top>
~)
</whdroplet>

<!---finish the yellow table past the results.-->
<whdroplet name="AsyncPageTail">
(~MATCH|(~AsyncDemo~)!Percent|
</td></tr></table>
||<hr />
~)

(~IF|AsyncSplitLoop
|(~AsyncPageTailLoop~)
||(~JUMP|Async|Continue..~)
~)

<br/><br/>
(~drPageEnd~)
</div></body></html>
</whdroplet>

<whdoc>
as this chunk is expanded BEFORE the result is actually in,
using (~BOUNCE|Async~) does not advance you from 'here'.
(even if the bounce is _actually done by the runner now, your browser
would already have processed the document header.
so, let us use JavaScript to display the main/completion page:
</whdoc>

<whdroplet name="AsyncPageTailLoop">
<script language="JavaScript"><!--
window.location = "(~DynURL.ToSessionIDW~)"; // -->
</script>
</whdroplet>

</whteko>
